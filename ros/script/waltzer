#! /usr/bin/env python

from __future__ import print_function

import rospy
import time
from geometry_msgs.msg import Twist, PoseArray
from nav_msgs.msg import Odometry
from waltzing_robot.waypoints import Waypoints, Waypoint
from waltzing_robot.vel_curve_handler import VelCurveHandler
from waltzing_robot.utils import Utils

class Waltzer(object):

    """Waltzer ros node"""

    def __init__(self):
        # read ros param
        cmd_vel_topic = rospy.get_param('~cmd_vel_topic', '/cmd_vel')
        odom_topic = rospy.get_param('~odom_topic', '/ropod/odom_incomplete')
        waypoint_config = rospy.get_param('~waypoint_config', None)
        waypoints_topic = rospy.get_param('~waypoint_topic', '/ropod/waypoints')
        trajectory_topic = rospy.get_param('~trajectory_topic', '/ropod/trajectory')
        sleep_duration = rospy.get_param('~sleep_duration', 0.1)

        # class variables
        self.frame_id = waypoint_config.get('frame', 'odom')
        if waypoint_config is not None:
            self.waypoints = Waypoints(waypoint_config=waypoint_config)
        else:
            self.waypoints = Waypoints()
        self._vel_curve_handler = VelCurveHandler()
        self.current_position = (0.0, 0.0, 0.0)

        # publishers
        self._cmd_vel_pub = rospy.Publisher(cmd_vel_topic, Twist, queue_size=1)
        self._waypoints_pub = rospy.Publisher(waypoints_topic, PoseArray, queue_size=1)
        self._trajectory_pub = rospy.Publisher(trajectory_topic, PoseArray, queue_size=1)

        # subscribers
        self._odom_sub = rospy.Subscriber(odom_topic, Odometry, self._odom_cb)
        
        time.sleep(1) # sleep to initialise publishers completely
        self._waypoints_pub.publish(self.waypoints.to_pose_array())

    def _odom_cb(self, msg):
        self.current_position = Utils.get_x_y_theta_from_pose(msg.pose.pose)

    def follow_waypoints(self):
        """Follow waypoints defined by class variable with their vel curve motion
        :returns: None

        """
        start_time = rospy.get_time()
        # Assumption: robot is initially at origin
        current = Waypoint({'x': 0.0, 'y': 0.0, 'theta': 0.0, 'time':0.0})
        for wp in self.waypoints.waypoints:
            print(wp)
            self._vel_curve_handler.set_delta(wp - current)
            # print(self._vel_curve_handler)
            while start_time + wp.time > rospy.get_time():
                if rospy.is_shutdown():
                    self._cmd_vel_pub.publish(self._get_twist())
                    return
                x, y, theta = self._vel_curve_handler.get_vel(
                        rospy.get_time() - start_time - current.time,
                        self.current_position)
                # print(x, y, theta)
                self._cmd_vel_pub.publish(self._get_twist(x, y, theta))
                rospy.sleep(0.1)
            current = wp
        self._cmd_vel_pub.publish(self._get_twist())

    def visualise_trajectory(self):
        """Publish PoseArray representing the trajectory
        :returns: None

        """
        current = Waypoint({'x': 0.0, 'y': 0.0, 'theta': 0.0, 'time':0.0})
        current_time = 0.0
        delta_time = 0.1
        x = current.x
        y = current.y
        theta = current.theta
        pose_array = PoseArray()
        pose_array.header.frame_id = self.frame_id
        pose_array.header.stamp = rospy.Time.now()
        poses = []
        for wp in self.waypoints.waypoints:
            self._vel_curve_handler.set_delta(wp - current)
            while current_time < wp.time:
                # current position has to be given (0,0,0) because the cmd_vel
                # are applied in robot's frame whereas the poses are published
                # in global frame
                x_vel, y_vel, theta_vel = self._vel_curve_handler.get_vel(
                        current_time - current.time,
                        (0.0, 0.0, 0.0))
                x += x_vel*delta_time
                y += y_vel*delta_time
                theta += theta_vel*delta_time
                pose = Utils.get_pose_from_x_y_theta(x, y, theta)
                poses.append(pose)
                current_time += delta_time
                # time.sleep(delta_time)
                # pose_array.poses = poses
                # self._trajectory_pub.publish(pose_array)
            current = wp
        pose_array.poses = poses
        self._trajectory_pub.publish(pose_array)


    def waltz(self):
        """ Make the robot follow waltz type motion in a square
        :returns: None

        """
        rospy.loginfo('[Waltzer] Starting waltzing')
        # hack to make the simulation return actual time
        while rospy.get_time() <= 0.0:
            rospy.sleep(0.1)

        timeout = 2.0
        direction = [{'x':1, 'y':0}, {'x':0, 'y':1}, {'x':-1, 'y':0}, {'x':0, 'y':-1}]
        for _ in range(3):
            for i in range(len(direction)):
                start_time = rospy.get_time()
                while rospy.get_time() - start_time < timeout:
                    if rospy.is_shutdown():
                        self._cmd_vel_pub.publish(self._get_twist())
                        return
                    vel = self._get_vel_based_on_time(rospy.get_time() - start_time, timeout)
                    self._cmd_vel_pub.publish(self._get_twist(
                        x=vel*direction[i]['x'],
                        y=vel*direction[i]['y']))
                    rospy.sleep(0.2)
        self._cmd_vel_pub.publish(self._get_twist())
        rospy.loginfo('[Waltzer] Finished waltzing')

    def _get_twist(self, x=0.0, y=0.0, theta=0.0):
        """Return twist ros message object.

        :x: float
        :y: float
        :theta: float
        :returns: geometry_msgs.msg.Twist

        """
        msg = Twist()
        msg.linear.x = x
        msg.linear.y = y
        msg.angular.z = theta
        return msg

    def _get_vel_based_on_time(self, t, tmax=2.0, vmax=4.0, r=0.01):
        """
        :t: float (between 0 and tmax)
        :tmax: float (+ve)
        :vmax: float (+ve) maximum velocity
        :r: float (radius/damping factor)(between 0 and 1)
        """
        if t < 0:
            return vmax
        elif t > tmax:
            return 0.0
        else:
            return vmax * (r ** (t/tmax))

if __name__ == "__main__":
    rospy.init_node('waltzer')
    WALTZER = Waltzer()
    # WALTZER.waltz()
    # WALTZER.follow_waypoints()
    WALTZER.visualise_trajectory()
