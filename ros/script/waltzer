#! /usr/bin/env python

from __future__ import print_function

import rospy
from geometry_msgs.msg import Twist, PoseArray
from waltzing_robot.waypoints import Waypoints

class Waltzer(object):

    """Waltzer ros node"""

    def __init__(self):
        # read ros param
        cmd_vel_topic = rospy.get_param('~cmd_vel_topic', '/cmd_vel')
        waypoint_config = rospy.get_param('~waypoint_config', None)
        waypoints_topic = rospy.get_param('~waypoint_topic', '/ropod/waypoints')

        # class variables
        if waypoint_config is not None:
            self.waypoints = Waypoints(waypoint_config=waypoint_config)
        else:
            self.waypoints = Waypoints()

        # publishers
        self.cmd_vel_pub = rospy.Publisher(cmd_vel_topic, Twist, queue_size=1)
        self.waypoints_pub = rospy.Publisher(waypoints_topic, PoseArray, queue_size=1)

        # subscribers
        
        self.waypoints_pub.publish(self.waypoints.to_pose_array())
        print(self.waypoints)

    def waltz(self):
        """ Make the robot follow waltz type motion in a square
        :returns: None

        """
        rospy.loginfo('[Waltzer] Starting waltzing')
        # hack to make the simulation return actual time
        while rospy.get_time() <= 0.0:
            rospy.sleep(0.1)

        timeout = 2.0
        direction = [{'x':1, 'y':0}, {'x':0, 'y':1}, {'x':-1, 'y':0}, {'x':0, 'y':-1}]
        for _ in range(3):
            for i in range(len(direction)):
                start_time = rospy.get_time()
                while rospy.get_time() - start_time < timeout:
                    if rospy.is_shutdown():
                        self.cmd_vel_pub.publish(self._get_twist())
                        return
                    vel = self._get_vel_based_on_time(rospy.get_time() - start_time, timeout)
                    self.cmd_vel_pub.publish(self._get_twist(
                        x=vel*direction[i]['x'],
                        y=vel*direction[i]['y']))
                    rospy.sleep(0.2)
        self.cmd_vel_pub.publish(self._get_twist())
        rospy.loginfo('[Waltzer] Finished waltzing')

    def _get_twist(self, x=0.0, y=0.0, theta=0.0):
        """Return twist ros message object.

        :x: float
        :y: float
        :theta: float
        :returns: geometry_msgs.msg.Twist

        """
        msg = Twist()
        msg.linear.x = x
        msg.linear.y = y
        msg.angular.z = theta
        return msg

    def _get_vel_based_on_time(self, t, tmax=2.0, vmax=4.0, r=0.01):
        """
        :t: float (between 0 and tmax)
        :tmax: float (+ve)
        :vmax: float (+ve) maximum velocity
        :r: float (radius/damping factor)(between 0 and 1)
        """
        if t < 0:
            return vmax
        elif t > tmax:
            return 0.0
        else:
            return vmax * (r ** (t/tmax))

if __name__ == "__main__":
    rospy.init_node('waltzer')
    WALTZER = Waltzer()
    # WALTZER.waltz()
